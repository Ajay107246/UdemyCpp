#include "../header/lambdaExpressions.hpp"

/*
    74-5: below lambda expresssion represented as fucntion object using struct (internally by compiler)
    this could be as below
*/
struct Unnamed{
    int operator()(int x, int y)const{
    return x+y;
    }
};

void all_lambda_expressions_methods()
{
    /*
        74-1, simple lambda expression
        [] introducer, () args
        inside body simple cout statement
        whole part is anonymous function objects and to invoke the overloaded function call operator of this anonymous function object
        at end function call () operator can be use

        lambda expression is internally implemented as function object that compiler creates a class and overloads the function call operator in it
        function call operator will contain the implementation body of lambda expression

        since class name is unknown that compiler internally uses, instance of lambda expression can get thorugh auto keyword
        
        74-2, **create a variable (type: auto) 'fnLambda' holds lambda expression and remove function call operator () at end **
        -> check (74-2).
    */
    [](){
        std::cout << "74-1, Welcome to lambda expressions!" << std::endl;
    }();    //() - invoked the lambda expression

    /*
        output:
        Topic74, lambda expression in C++11
        74-1, Welcome to lambda expressions!
    */

    //74-2, fnLambda : function object instance, use it like fnLambda() to invoke lambda expression 
    auto fnLambda = [](){
        std::cout << "74-2, lambda expressions with variable to invoked it and without function call operator()!" << std::endl;
    };
    fnLambda();

    /*
        output:
        Topic74, lambda expression in C++11
        74-1, Welcome to lambda expressions!
        74-2, lambda expressions with variable to invoked it and without function call operator()!

        check the type of fnLambda using typeid  
    */
    // std::cout << typeid(fnLambda).name() << std::endl;// output(OK, but machine readable, not human): Z30all_lambda_expressions_methodsvEUlvE0_
    int status;
    char* deMangled = abi::__cxa_demangle(typeid(fnLambda).name(),0,0, &status);
    std::cout << (status == 0 ? deMangled : typeid(fnLambda).name()) << std::endl;    
    free(deMangled);
    /*
        output:
        all_lambda_expressions_methods()::{lambda()#2}

        description:
        ouput indicates that the lambda is defined within the scope of the all_lambda_expressions_methods() function

        also, human-readable type name of the lambda, indicating 
        it is an unnamed class type generated by the compiler for the lambda expression
        
        The #2 in the printed output all_lambda_expressions_methods()::{lambda()#2} indicates that 
        this is the second lambda expression defined within the all_lambda_expressions_methods() function.
        If you had multiple lambda expressions within the same function, they would be numbered sequentially, such as #2, #3, and so on.

        This numbering helps distinguish between different lambda expressions within the same scope, 
        as each lambda has a unique, unnamed class type generated by the compiler
    */

    /*
        Topic74-4, Lambda expression that adds 2 nums and return sum
        1.  here, if lambda expression contains return statements that return the same type
            then no need to specify the return type
        2.  if the lambda expression returns void in that case return type -> optionals
        3.  if the body of lambda expression has multiple return statements and they return different types,
            then specify explicitly return type of lambda expression  
            e.g. in Sum(), trailing function syntax as
            auto Sum = [](int x, int y)->int{}

            return type of lambda expression is integer.

        4.  if do not specify the type, and returning different types from lambda expression
            e.g. return type => double -> it would not compile and throw error: all return expression must deduce to same type

           in this case, need to specify explicitly return type ->int/double
            auto Sum = [](int x, int y)->double{}

            this will compile okay.
    */
    // auto Sum = [](int x, int y)->double{
    std::cout << "\nTopic74-4, Lambda expression that adds 2 nums and return sum!" << std::endl;
    auto Sum = [](int x, int y){
        /*
            if(true)
                //won't compile due to, its deduce to same type if return type: ->int
                //but return type is double, it will compile
                return 5.0; 
        */
        return x + y;
    };
    std::cout << "Sum(5,2): " << Sum(5,2) << std::endl;
    
    /*
        output: 
        Topic74-4, Lambda expression that adds 2 nums and return sum!       
        Sum(5,2): 7

        this Sum() lambda expression represented as struct,
        have any name
        return type: int 
        accepts 2 args
        
        struct Unnamed{
        int operator()(int x, int y)const{
            return x+y;
        }
        };

        create instance of unnamed object then invoked it
        Unnamed n;  //instance
        cout << n(5,2); //invoked

        output:
        Topic74-5, function object representation of Sum() Lambda expression (internally by compiler)!
        uStrt(7,2): 9
    */
    std::cout << "\nTopic74-5, function object representation of Sum() Lambda expression (internally by compiler)!" << std::endl;
    Unnamed uStrt;
    std::cout << "uStrt(7,2): " << uStrt(7,2) << std::endl;

}