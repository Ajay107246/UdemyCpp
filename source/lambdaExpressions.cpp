#include "../header/lambdaExpressions.hpp"

void all_lambda_expressions_methods()
{
    /*
        74-1, simple lambda expression
        [] introducer, () args
        inside body simple cout statement
        whole part is anonymous function objects and to invoke the overloaded function call operator of this anonymous function object
        at end function call () operator can be use

        lambda expression is internally implemented as function object that compiler creates a class and overloads the function call operator in it
        function call operator will contain the implementation body of lambda expression

        since class name is unknown that compiler internally uses, instance of lambda expression can get thorugh auto keyword
        
        74-2, **create a variable (type: auto) 'fnLambda' holds lambda expression and remove function call operator () at end **
        -> check (74-2).
    */
    [](){
        std::cout << "74-1, Welcome to lambda expressions!" << std::endl;
    }();    //() - invoked the lambda expression

    /*
        output:
        Topic74, lambda expression in C++11
        74-1, Welcome to lambda expressions!
    */

    //74-2, fnLambda : function object instance, use it like fnLambda() to invoke lambda expression 
    auto fnLambda = [](){
        std::cout << "74-2, lambda expressions with variable to invoked it and without function call operator()!" << std::endl;
    };
    fnLambda();

    /*
        output:
        Topic74, lambda expression in C++11
        74-1, Welcome to lambda expressions!
        74-2, lambda expressions with variable to invoked it and without function call operator()!

        check the type of fnLambda using typeid  
    */
    // std::cout << typeid(fnLambda).name() << std::endl;// output(OK, but machine readable, not human): Z30all_lambda_expressions_methodsvEUlvE0_
    int status;
    char* deMangled = abi::__cxa_demangle(typeid(fnLambda).name(),0,0, &status);
    std::cout << (status == 0 ? deMangled : typeid(fnLambda).name()) << std::endl;    
    free(deMangled);
    /*
        output:
        all_lambda_expressions_methods()::{lambda()#2}

        description:
        ouput indicates that the lambda is defined within the scope of the all_lambda_expressions_methods() function

        also, human-readable type name of the lambda, indicating 
        it is an unnamed class type generated by the compiler for the lambda expression
        
        The #2 in the printed output all_lambda_expressions_methods()::{lambda()#2} indicates that 
        this is the second lambda expression defined within the all_lambda_expressions_methods() function.
        If you had multiple lambda expressions within the same function, they would be numbered sequentially, such as #2, #3, and so on.

        This numbering helps distinguish between different lambda expressions within the same scope, 
        as each lambda has a unique, unnamed class type generated by the compiler
    */
}