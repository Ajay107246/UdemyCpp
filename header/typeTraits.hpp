#pragma once
#ifndef TYPETRAITS__H
#define TYPETRAITS__H

#include<iostream>
#include<type_traits>

using namespace std;

/*
    description:
    c++ doesn't support introspection at runtime
    c++11 introduce type traits
    it give ablility to introspect
    find characteristics of types at compiler time
    tranform properties of type
    useful in template metaprogramming
    
    template metaprogramming: compiler compiles template based code and
    generates new code out of it.
    since cide is generated by compiler, code is highly optimized, i.y.
    template metaprogramming is used for creating high performance code
    using t.m. you can evaluate expessions or return values of functions at compile time
    when inspecting types through type traits, they will either return boolean or a type
    this provide a 'template based interface' becuase most type traits are implemented as class tempates, 
    but some traits will require support from compiler, can not be implemented through code
    compiler provides intrinsics for such traits    
    
    defined in header <type_traits>
    some traits added in c++11:    
    is_void : chk if type is void
    is_pointer : chk if type is ptr
    is_null_pointer : chk if type is null_ptr_t
    is_integral : chk if type is integral
    is_floating_point : chk if type is flaoting point
    is_array : chk if type is array
    is_enum : chk if type is enum
    is_union : chk if type is union
    is_class : chk if type is non-class type
    is_function : chk if type is function

    some of traits added in c++14
    type traits always used with template

*/

template<typename T>
T devide(T a, T b);

template<typename T>
void check(T&&);   

void all_type_traits_methods();

#endif //TYPETRAITS__H
#pragma endregion

